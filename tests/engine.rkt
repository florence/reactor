#lang racket
(require reactor reactor/engine)
(module+ test
  (require rackunit)
  (require racket/async-channel)
  (test-begin
   (define-signal S)
   (react! (prime (process (emit& S))))
   (check-eq? (sync/timeout 0 S) S))

  (test-begin
   (define-signal S)
   (define-signal O)
   (define r (prime (process (await& #:immediate S) (emit& O))))
   (ignition! r)
   (check-true (reactor-ignited? r))
   (check-false (sync/timeout 0 O))
   (queue-emission! r S)
   (check-eq? (sync/timeout 1 O) O)
   (shutdown! r)
   (check-false (reactor-ignited? r)))
  (test-begin
   (define-signal S)
   (define-signal O)
   (define r (prime (process (await& #:immediate S) (emit& O))))
   (ignition! r)
   (check-true (reactor-ignited? r))
   (check-false (sync/timeout 0 O))
   (queue-emission! r S)
   (shutdown! r)
   (check-false (reactor-ignited? r))
   (check-eq? (sync/timeout 1 O) O))
  (test-begin
   (define-signal S)
   (define-signal O)
   (define r (prime (process (await& #:immediate S) (emit& O))))
   (ignition! r)
   (define s (make-semaphore 1))
   (define evt2 (bind-signal r S s))
   (check-not-false (sync/timeout 0 evt2))
   (check-eq? (sync/timeout 1 O) O)
   (shutdown! r)
   (check-false (reactor-ignited? r)))
  (test-begin
   (define-signal S 0 #:gather +)
   (define-signal O 0 #:gather +)
   (define chan (make-async-channel))
   (define r (prime (process (loop& (await& S [v (emit& O (add1 v))])))))
   (ignition! r)
   (define evt2 (bind-signal r S chan))
   (for ([i (in-range 10)])
     (async-channel-put chan i)
     (check-equal? (sync/timeout 10 evt2) evt2)
     (check-equal? (last (sync/timeout 10 O)) (add1 i)))
   (shutdown! r)
   (check-false (reactor-ignited? r)))
  (test-begin
   (define-signal S 0 #:gather +)
   (define-signal O 0 #:gather +)
   (define chan (make-async-channel))
   (define r (prime (process (loop& (await& S [v (emit& O (add1 v))])))))
   (ignition! r)
   (check-true (reactor-ignited? r))
   (define evt2 (bind-signal r S chan))
   (shutdown! r)
   (check-false (reactor-ignited? r))
   (ignition! r)
   (check-true (reactor-ignited? r))
   (for ([i (in-range 3)])
     (async-channel-put chan i)
     (check-equal? (sync/timeout 1 evt2) #f)
     (check-equal? (sync/timeout 1 O) #f))
   (shutdown! r)
   (check-false (reactor-ignited? r)))
  (test-begin
   ;; ok here we cheat a little: force suspend the reaction thread so we can
   ;; queue up several messages
   (define ithreads (dynamic-require/expose 'reactor/engine 'ignition-threads))
   (define ict (dynamic-require/expose 'reactor/engine 'ignition-control-thread))
   (define-signal S1)
   (define-signal O1)
   (define-signal S2)
   (define-signal O2)
   (define r (prime (process (par& (begin (await& #:immediate S1) (emit& O1)))
                                   (begin (await& #:immediate S2) (emit& O2)))))
   (ignition! r)
   (define td (ict (hash-ref ithreads r)))
   (thread-suspend td)
   (queue-emission! r S1)
   (queue-emission! r S2)
   ;; shutdown! blocks, must send manually
   (thread-send td 'shutdown!)
   (thread-resume td)
   (check-not-false (sync/timeout 3 O1))
   (check-not-false (sync/timeout 3 O2))
   (check-true (thread-dead? td))
   (hash-remove! ithreads r)))
   