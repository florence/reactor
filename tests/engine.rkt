#lang racket
(require reactor reactor/engine)
(module+ test
  (require rackunit)
  (require racket/async-channel)
  (test-begin
   (define-signal S)
   (react! (prime (process (emit& S))))
   (check-eq? (sync/timeout 0 S) S))

  (test-begin
   (define-signal S)
   (define-signal O)
   (define r (prime (process (await& #:immediate S) (emit& O))))
   (ignition! r)
   (check-false (sync/timeout 0 O))
   (queue-emission! r S)
   (check-eq? (sync/timeout 1 O) O)
   (shutdown! r))
  (test-begin
   (define-signal S)
   (define-signal O)
   (define r (prime (process (await& #:immediate S) (emit& O))))
   (ignition! r)
   (check-false (sync/timeout 0 O))
   (queue-emission! r S)
   (shutdown! r)
   (check-eq? (sync/timeout 1 O) O))
  (test-begin
   (define-signal S)
   (define-signal O)
   (define r (prime (process (await& #:immediate S) (emit& O))))
   (ignition! r)
   (define s (make-semaphore 1))
   (define evt2 (bind-signal r S s))
   (check-not-false (sync/timeout 0 evt2))
   (check-eq? (sync/timeout 1 O) O)
   (shutdown! r))
  (test-begin
   (define-signal S 0 #:gather +)
   (define-signal O 0 #:gather +)
   (define chan (make-async-channel))
   (define r (prime (process (loop& (await& S [v (emit& O (add1 v))])))))
   (ignition! r)
   (define evt2 (bind-signal r S chan))
   (for ([i (in-range 10)])
     (async-channel-put chan i)
     (check-equal? (sync/timeout 10 evt2) evt2)
     (check-equal? (last (sync/timeout 10 O)) (add1 i)))
   (shutdown! r))
  (test-begin
   (define-signal S 0 #:gather +)
   (define-signal O 0 #:gather +)
   (define chan (make-async-channel))
   (define r (prime (process (loop& (await& S [v (emit& O (add1 v))])))))
   (ignition! r)
   (define evt2 (bind-signal r S chan))
   (shutdown! r)
   (ignition! r)
   (for ([i (in-range 3)])
     (async-channel-put chan i)
     (check-equal? (sync/timeout 1 evt2) #f)
     (check-equal? (sync/timeout 1 O) #f))
   (shutdown! r)))